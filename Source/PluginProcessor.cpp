/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/
#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "FloatParameter.h"

//==============================================================================
PureDataAudioProcessor::PureDataAudioProcessor() : receiver(&parameterList, this)
#ifndef JucePlugin_PreferredChannelConfigurations
     : AudioProcessor (BusesProperties()
                     #if ! JucePlugin_IsMidiEffect
                      #if ! JucePlugin_IsSynth
                       .withInput  ("Input",  AudioChannelSet::stereo(), true)
                      #endif
                       .withOutput ("Output", AudioChannelSet::stereo(), true)
                     #endif
                       )
#endif
{
    /*
    for (int i=0; i<10; i++) {
        FloatParameter* p = new FloatParameter (0.5, ("Param" + (String) (i+1)).toStdString());
        parameterList.add(p);
        addParameter(p);
    }
     */
    
    /*
    addParameter (freq = new FloatParameter (440.0f/2000.0f, "Frequency"));
    addParameter (volume = new FloatParameter (0.2f, "Volume"));
    addParameter (del_delay = new FloatParameter (0.5f, "Del-Delay"));
    addParameter (del_feedback = new FloatParameter (1.15627f, "Del-Feedback"));
    addParameter (del_mode_rate = new FloatParameter (0.5f, "Del-Mod-Rate"));
    addParameter (del_mode_depth = new FloatParameter (0.5f, "Del-Mod-Depth"));
    */
}

PureDataAudioProcessor::~PureDataAudioProcessor()
{
    pd = nullptr;
}

//==============================================================================

void PureDataAudioProcessor::setParameterName(int index, String name)
{
    FloatParameter* p = parameterList.getUnchecked(index);
    p->setName(name);
}

void PureDataAudioProcessor::setPatchFile(juce::File file)
{
    patchfile = file;
}

void PureDataAudioProcessor::setParameterDefaults()
{
    /* */
    /* PROCESS BLOCK, RELEASE RESOURCES, GET & SET STATE INFORMATION e checar o resto */
}

t_pdinstance* PureDataAudioProcessor::getPDInstance() {
    return pd_instance;
}

void PureDataAudioProcessor::reloadPatch (double sampleRate)
{
    /* AQUI !!!
     if (isInstanceLocked) {
     status = "Currently only one simultaneous instance of this plugin is allowed";
     return;
     }
     */
    
    if (sampleRate) {
        cachedSampleRate = sampleRate;
    } else {
        sampleRate = cachedSampleRate;
    }
    
    fprintf(stderr,"PureDataAudioProcessor::reloadPatch() %d ",(int)sampleRate);
    
    if (pd) {
        pd->computeAudio(false);
        pd->closePatch(patch);
    }
    
    /// !!! !!! !!!
    
    pd = new pd::PdBase;
    
    //pd_setinstance(pd_instance);
    
    pd->init (2, 2, sampleRate); // !!! FIX
    
    int numChannels = jmin (2, 2); // !!! FIX
    pdInBuffer.calloc (pd->blockSize() * numChannels);
    pdOutBuffer.calloc (pd->blockSize() * numChannels);
    
    // subscribe before openpatch, to be ready at loadbang time
    pd->setReceiver(&receiver);
    pd->unsubscribeAll(); //AQUI !!!
    
    for (int i=1; i <= parameterList.size(); i++) {
        String identifier;
        identifier << receiver.paramIdentifier << i;
        pd->subscribe(identifier.toStdString());
    }
    
    
    if (!patchfile.exists()) {
        if (patchfile.getFullPathName().toStdString() != "") {
 //           status = "File does not exist";
        }
        // else keeps select patch message
        return;
    }
    
    if (patchfile.isDirectory()) {
  //      status = "You selected a directory";
        return;
    }
    
    patch = pd->openPatch (patchfile.getFileName().toStdString(), patchfile.getParentDirectory().getFullPathName().toStdString());
    
    if (patch.isValid()) {
        pd->computeAudio (true);
        if(!patchLoadError) {
    //        status = "Patch loaded successfully";
        }
        patchLoadError = false;
    } else {
//        status = "Selected patch is not valid";
    }
    
}

//=======
const String PureDataAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

const String PureDataAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String PureDataAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool PureDataAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool PureDataAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool PureDataAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool PureDataAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool PureDataAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double PureDataAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int PureDataAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int PureDataAudioProcessor::getCurrentProgram()
{
    return 0;
}

void PureDataAudioProcessor::setCurrentProgram (int index)
{
}

const String PureDataAudioProcessor::getProgramName (int index)
{
    return String();
}

void PureDataAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void PureDataAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    reloadPatch(sampleRate);
    
    pos = 0;
/*
    pd = new pd::PdBase;
    pd->init (getNumInputChannels(), getNumOutputChannels(), sampleRate);

    int numChannels = jmin (getNumInputChannels(), getNumOutputChannels());
    pdInBuffer.calloc (pd->blockSize() * numChannels);
    pdOutBuffer.calloc (pd->blockSize() * numChannels);
    patch = pd->openPatch ("test4.pd", "/Users/olivergreschke/Documents/JUCEPureData/Source");
    jassert (patch.isValid());
	
    pd->computeAudio (true);
    pos = 0;
*/
}

void PureDataAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
    
    if (pd != nullptr)
    {
        pd->computeAudio (false);
        pd->closePatch (patch);
    }

    pd = nullptr;
    pdInBuffer.free();
    pdOutBuffer.free();
    
}


void PureDataAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    pd->receiveMessages();
    
    // Send host info messages
    {
        AudioPlayHead::CurrentPositionInfo info;
        getPlayHead()->getCurrentPosition(info);
        if (positionInfo.isPlaying != info.isPlaying) {
            pd->sendMessage("hostIsPlaying", info.isPlaying ? "true" : "false");
        }
        if (positionInfo.bpm != info.bpm) {
            pd->sendFloat("hostBpm", (float) info.bpm); //!!! AQUI !!! (pd set instance thing)
            //AQUI !!!
        }
        positionInfo = info;
    }
    
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i) {
        buffer.clear (i, 0, buffer.getNumSamples());
    }
    
    int numChannels = jmin (getNumInputChannels(), getNumOutputChannels());
    int len = buffer.getNumSamples();
    int idx = 0;
    
    for (int i=0; i<parameterList.size(); i++) {
        FloatParameter* parameter = parameterList[i];
        pd->sendFloat(parameter->getName(300).toStdString(), parameter->getValue());
    }
    
    MidiMessage message;
    MidiBuffer::Iterator it (midiMessages);
    int samplePosition = buffer.getNumSamples();
    
    while (it.getNextEvent (message, samplePosition))
    {
        if (message.isNoteOn (true)) {
            pd->sendNoteOn (message.getChannel(), message.getNoteNumber(), message.getVelocity());
        }
        if (message.isNoteOff (true)) {
            pd->sendNoteOn (message.getChannel(), message.getNoteNumber(), 0);
        }
    }
    
    while (len > 0)
    {
        int max = jmin (len, pd->blockSize());
        
        /* interleave audio */
        {
            float* dstBuffer = pdInBuffer.getData();
            for (int i = 0; i < max; ++i)
            {
                for (int channelIndex = 0; channelIndex < numChannels; ++channelIndex)
                    *dstBuffer++ = buffer.getReadPointer(channelIndex) [idx + i];
            }
        }
        
        pd->processFloat (1, pdInBuffer.getData(), pdOutBuffer.getData());
        
        /* write-back */
        {
            const float* srcBuffer = pdOutBuffer.getData();
            for (int i = 0; i < max; ++i)
            {
                for (int channelIndex = 0; channelIndex < numChannels; ++channelIndex)
                    buffer.getWritePointer (channelIndex) [idx + i] = *srcBuffer++;
            }
        }
        
        idx += max;
        len -= max;
    }
    
    
    // In case we have more outputs than inputs, this code clears any output channels that didn't contain input data, (because these aren't guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback when they first compile the plugin, but obviously you don't need to this code if your algorithm already fills all the output channels.
    //const int totalNumInputChannels  = getTotalNumInputChannels();
    //const int totalNumOutputChannels = getTotalNumOutputChannels();

    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // This is here to avoid people getting screaming feedback
    // when they first compile a plugin, but obviously you don't need to keep
    // this code if your algorithm always overwrites all the output channels.
    /*
    for (int i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
        buffer.clear (i, 0, buffer.getNumSamples());
    */
    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
    /*
    for (int channel = 0; channel < totalNumInputChannels; ++channel)
    {
        float* channelData = buffer.getWritePointer (channel);

        // ..do something to the data...
    }
    */
/* 
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());
    
    int numChannels = jmin (getNumInputChannels(), getNumOutputChannels());
    int len = buffer.getNumSamples();
    int idx = 0;
    
    //pd->sendFloat ("freq", freq->getValue() * 2000.0f);
    //pd->sendFloat ("volume", volume->getValue() * 1.0f);
    pd->sendFloat ("del_delay", del_delay->getValue() );
    pd->sendFloat ("del_feedback", del_feedback->getValue() );
    pd->sendFloat ("del_mod_rate", del_mode_rate->getValue() );
    pd->sendFloat ("del_mod_depth", del_mode_depth->getValue() );
    
    //pd->sendNoteOn(<#const int channel#>, <#const int pitch#>)
    
    MidiMessage message;
    MidiBuffer::Iterator it (midiMessages);
    int samplePosition = buffer.getNumSamples();
    
    while (it.getNextEvent (message, samplePosition))
    {
        if (message.isNoteOn (true)) {
            pd->sendFloat("freq",powf(2.0, (message.getNoteNumber() - 69 ) / 12)*440.0);
            pd->sendNoteOn (message.getChannel(), message.getNoteNumber(), message.getVelocity());
            pd->sendFloat("volume",message.getVelocity()/128.0f );
        }
        if (message.isNoteOff (true)) {
            pd->sendFloat("volume",0.0 );
        }    }



    while (len > 0)
    {
        int max = jmin (len, pd->blockSize());
        
        // interleave audio 
        {
            float* dstBuffer = pdInBuffer.getData();
            for (int i = 0; i < max; ++i)
            {
                for (int channelIndex = 0; channelIndex < numChannels; ++channelIndex)
                    *dstBuffer++ = buffer.getReadPointer(channelIndex) [idx + i];
            }
        }
        
        pd->processFloat (1, pdInBuffer.getData(), pdOutBuffer.getData());
        
        // write-back 
        {
            const float* srcBuffer = pdOutBuffer.getData();
            for (int i = 0; i < max; ++i)
            {
                for (int channelIndex = 0; channelIndex < numChannels; ++channelIndex)
                    buffer.getWritePointer (channelIndex) [idx + i] = *srcBuffer++;
            }
        }
        
        idx += max;
        len -= max;
    }
*/

}


/*
 
 // Other version of processBlock from Fabian to integrate Midi and to prevent audio buffer underuns ???
 
 void PureDataAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
 {
 // In case we have more outputs than inputs, this code clears any output
 // channels that didn't contain input data, (because these aren't
 // guaranteed to be empty - they may contain garbage).
 // I've added this to avoid people getting screaming feedback
 // when they first compile the plugin, but obviously you don't need to
 // this code if your algorithm already fills all the output channels.
 for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
 buffer.clear (i, 0, buffer.getNumSamples());
 
 int numChannels = jmin (getNumInputChannels(), getNumOutputChannels());
 int len = buffer.getNumSamples();
 int idx = 0;
 
 pd->sendFloat ("freq", freq->getValue() * 2000.0f);
 pd->sendFloat ("volume", volume->getValue() * 1.0f);
 pd->sendFloat ("del_delay", del_delay->getValue() );
 pd->sendFloat ("del_feedback", del_feedback->getValue() );
 pd->sendFloat ("del_mod_rate", del_mode_rate->getValue() );
 pd->sendFloat ("del_mod_depth", del_mode_depth->getValue() );
 
 MidiMessage message;
 int samplePosition = buffer.getNumSamples();
 MidiBuffer::Iterator it (midiMessages);
 
 if (! it.getNextEvent (message, samplePosition))
 {
	samplePosition = buffer.getNumSamples();
 }
 
 while (len > 0)
 {
	int max = jmin (len, pd->blockSize());
 
	// interleave audio
	{
 float* dstBuffer = pdInBuffer.getData() + pos;
 const float* srcBuffer = pdOutBuffer.getData() + pos;
 
 for (int i = 0; i < max; ++i)
 {
 for (int channelIndex = 0; channelIndex < numChannels; ++channelIndex)
 {
 *dstBuffer++ = buffer.getReadPointer(channelIndex) [idx + i];
 buffer.getWritePointer (channelIndex) [idx + i] = *srcBuffer++;
 }
 }
 pos++;
	}
 
	if (pos >= pd->blockSize())
	{
 if (idx >= samplePosition && idx <= (samplePosition + pd->blockSize()))
 {
 if (message.isNoteOn (true))
 pd->sendNoteOn (message.getChannel(), message.getNoteNumber(), message.getVelocity());
 else if (message.isController())
 pd->sendControlChange (message.getChannel(), message.getControllerNumber(), message.getControllerValue());
 else if (message.isProgramChange())
 pd->sendProgramChange (message.getChannel(), message.getProgramChangeNumber());
 else if (message.isPitchWheel())
 pd->sendPitchBend (message.getChannel(), message.getPitchWheelValue());
 // TODO add remaining midi types
 
 if (! it.getNextEvent (message, samplePosition))
 {
 samplePosition = buffer.getNumSamples();
 }
 }
 pd->processFloat (1, pdInBuffer.getData(), pdOutBuffer.getData());
 pos = 0;
	}
 
	idx += max;
	len -= max;
 }
 }
 
 */


//==============================================================================
bool PureDataAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* PureDataAudioProcessor::createEditor()
{
    return new PureDataAudioProcessorEditor (*this);
}

//==============================================================================
void PureDataAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    XmlElement xml(getName().replace(" ", "-"));
    
    // patchfile
    XmlElement* patchfileElement = new XmlElement("patchfile");
    patchfileElement->setAttribute("path", patchfile.getParentDirectory().getFullPathName());
    patchfileElement->setAttribute("fullpath", patchfile.getFullPathName());
    patchfileElement->setAttribute("filename", patchfile.getFileName());
    xml.addChildElement(patchfileElement);
    
    // parameters
    XmlElement* parameterListElement = new XmlElement("parameterList");
    
    for(size_t i = 0; i < parameterList.size(); ++i) {
        
        XmlElement* parameterElement = new XmlElement("parameter");
        FloatParameter* parameter = parameterList[i];
        parameterElement->setAttribute("index", (int) parameter->getParameterIndex());
        parameterElement->setAttribute("name", parameter->getName(256));
        parameterElement->setAttribute("value", (double) parameter->getValue());
        
        parameterListElement->addChildElement(parameterElement);
    }
    xml.addChildElement(parameterListElement);
    
    MemoryOutputStream stream;
    xml.writeToStream(stream, "");
    //std::cout << "save [" << stream.toString() << "] " << std::endl;
    
    copyXmlToBinary(xml, destData);
}

void PureDataAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    ScopedPointer<XmlElement> xml(getXmlFromBinary(data, sizeInBytes));
    if(xml != 0 && xml->hasTagName(getName().replace(" ", "-"))) {
        
        MemoryOutputStream stream;
        xml->writeToStream(stream, "<?xml version=\"1.0\"?>");
        //std::cout << "load [" << stream.toString() << "] " << std::endl;
        
        forEachXmlChildElement (*xml, child)
        {
            //std::cout << " - load : " << child->getTagName() << std::endl;
            if(child->hasTagName("patchfile")) {
                File path(child->getStringAttribute ("fullpath"));
                if (path.exists()) {
                    patchfile = path; // creates a copy
                    reloadPatch(NULL);
                }
            }
            
            if(child->hasTagName("parameterList")) {
                forEachXmlChildElement (*child, parameterElement) {
                    
                    //std::cout << "loading param " << parameterElement->getStringAttribute("name");
                    //std::cout << "[" << parameterElement->getIntAttribute("index") << "]: ";
                    //std::cout << parameterElement->getDoubleAttribute("value") << std::endl;
                    
                    setParameter(parameterElement->getIntAttribute("index"), (float) parameterElement->getDoubleAttribute("value"));
                    setParameterName(parameterElement->getIntAttribute("index"), parameterElement->getStringAttribute("name"));
                }
            }
        }
    }
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new PureDataAudioProcessor();
}
